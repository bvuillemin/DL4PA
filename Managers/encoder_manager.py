"""
Deep Learning Framework
Version 1.0
Authors: Benoit Vuillemin, Frederic Bertrand
Licence: AGPL v3
"""

import itertools

import numpy as np
import pandas as pd


class EncoderManager:

    def __init__(self, encoders):
        """
        Creates an encoder manager, that is a combination of multiple encoders

        :param encoders: List of encoders to add to the manager
        :type encoders: list
        """
        self.encoders = encoders
        self.all_output_column_names = []
        self.remove_duplicate_leftovers()

    def set_all_output_column_names(self):
        """
        Aggregates the names of the new columns generated by all the encoders and store them inside the manager

        """
        self.all_output_column_names = list(
            itertools.chain.from_iterable(
                [encoder.output_column_names for encoder in self.encoders if encoder.output_column_names is not None]))

    def get_all_encoders_description_df(self):
        """
        Returns all the descriptions (type, input and output column(s)) from all the encoders into a dataframe

        :return: Infos on the encoders
        :rtype: str
        """
        results = []
        column_index = 0
        for e in self.encoders:
            result = e.get_description_df()
            if e.output_column_names is not None:
                if len(e.output_column_names) == 1:
                    result = result + ([column_index],)
                else:
                    result = result + ([column_index, column_index + len(e.output_column_names) - 1],)
                column_index += len(e.output_column_names)
            else:
                result = result + ("",)
            results.append(result)
        return pd.DataFrame(results, columns=['Name', 'Properties', 'Input column names', 'Input column indexes', 'Output column names', 'Output column indexes'])

    def get_all_encoders_description(self):
        """
        Returns all the descriptions (type, input and output column(s)) from all the encoders

        :return: Infos on the encoders
        :rtype: str
        """
        results = []
        column_index = 0
        for e in self.encoders:
            result = e.get_description()
            if e.output_column_names is not None:
                if len(e.output_column_names) == 1:
                    result = result + ([column_index],)
                else:
                    result = result + ([column_index, column_index + len(e.output_column_names) - 1],)
                column_index += len(e.output_column_names)
            else:
                result = result + ("",)
            results.append(result)
        return results

    def encode_case(self, case):
        """
        Encodes the chunk of data

        :param case: Case to process
        :type case: np.ndarray
        :return: Encoded chunk
        :rtype: np.ndarray
        """
        results = [encoder.encode_case(case) for encoder in self.encoders if encoder.output_column_names is not None]
        new_case = np.hstack(results)
        return new_case

    def get_leftover(self, case):
        """
        Gets the leftover built by all the encoders for a case

        :param case: Case to process
        :type case: np.ndarray
        :return: Array of leftovers
        :rtype: np.ndarray
        """
        leftover = [encoder.get_leftover(case) for encoder in self.encoders if encoder.leftover_name is not None]
        if leftover:
            every_leftover = np.hstack(leftover)
        else:
            every_leftover = np.asarray([])
        return every_leftover

    def remove_duplicate_leftovers(self):
        """
        Removes the duplicate leftovers. Used if multiple encoders process the same columns

        """
        previous_leftover = ""
        for encoder in self.encoders:
            if previous_leftover == encoder.leftover_name:
                encoder.leftover_name = None
            else:
                previous_leftover = encoder.leftover_name

    def get_leftover_names(self):
        """
        Returns the names of the columns of the leftovers built by all the encoders

        :return: Leftover names
        :rtype: list
        """
        return [encoder.leftover_name for encoder in self.encoders if encoder.leftover_name is not None]

    def get_encoder_counter(self):
        """
        Returns the total number of encoders inside the encoder manager

        :return: Number of encoders
        :rtype: int
        """
        return len(self.encoders)
